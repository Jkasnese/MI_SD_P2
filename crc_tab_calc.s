.data

# Alocating space to crc lookup table
table: .word 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF

.text

# Reads byte from RS232 and stores it into r10
__read_byte:

movia r15, 0x30f0 # Memory location of the new byte
movia r18, 0x30c0 # Memory location of the data read sign.

wait_data:
ldb r16, 0x0(r18)
bgt r16, r0, read
stb r0, 0x0(r18) # If there is no new data, it means you read the last data and the fpga already knows.
br wait_data

read:
ldbu r10, 0x0(r15) # Reads byte
movia r11, 0x1 
stb r11, 0x0(r18) r18 # Signals that byte was read.
ret

.global main 

main:

# Algorithm Configurations
movia r1, 0x100 # Table size in words = 2^8.
movui r4, 0x8 # Number of divisions or number of bits operated together on CRC algorithm 
movia r17, table # initial table position
# Initializing r9 to hold the poly
movui r9, 0x04C1
slli r9, r9, 0x10
ori r9, r9, 0x1DB7


# TABLE CALCULATION
mov r7, r17 # r7 gets permanent table position to iterate upon

movui r2, 0x0 # i=0. Will be incremented until table size.


# Table's FOR

next_number:
  bgeu r2, r1, begin_transmission # If i >= 256, table is over. Go to algorithm

mov r3, r2 # r3 == rem, rem=i

slli r3, r3, 0x18 # Makes it the top byto to be shifted left

movui r5, 0x0 # j = 0

# XOR's FOR

next_div:
  bge r5, r4, store_number # If already checked all the bits, store number.
  
andhi r6, r3, 0x8000 # compare msb
slli r3, r3, 0x1
beq r0, r6, dont_xor
xor r3, r3, r9
dont_xor:
  addi r5, r5, 0x1
br next_div

store_number:
  stw r3, 0(r7)

addi r2, r2, 0x1
addi r7, r7, 0x4 # Each position is 4 bytes in size (32 bits size)

br next_number

# END XOR FOR

# END TABLE CALCULATION

begin_transmission:

#
#    Registrador de configurações:
#
#    B0 (LSB) - Presença de paridade: (1 sim/ 0 não) - Use parity: (1 yes/ 0 no)
#    B1 - Paridade: (0 par/1impar) - Parity: (0 even, 1 0dd)
#    B2e3 - Dados: (11 5, 10 6, 01 7, 00 8) - Data bits per package
#    B4 - Stopbits: um 0, dois 1 - one 0, two 1
#    B5 - Handshake: (1sim/0não) - 1y/0n
#    B6e7 - Velocidade clock: (0 9600/ 1 19200 / 2 57600 / 3 115200 - Baudrate
#

movia r1, 0xC0 # Initial Configurations of RS232. See table above. 
movia r8, 0x30b0 # Address of RS232 configurations on FPGA
stb r1, 0x0(r8)
call __read_byte # Reads byte with new RS232 configurations
stb r10, 0x0(r8)

# Receive size of the message. First receive most significative byte, then less significative byte.
# Size of message is then stored in r8.
call __read_byte
mov r8, r10
slli r8, r8, 0x8
call __read_byte
or r8, r8, r10

# CRC CALCULATION

#movia r2, 0xFFFFFFFF # initial xor
ori r2, r2, 0xFFFF
slli r2, r2, 0x10
ori r2, r2, 0xFFFF

movi r3, 0x0 # i

crc_loop:
  bge r3, r8, crc2lcd

mov r4, r2 # byte "leaving" register tru right. To be xored with msg

# gets r2 high byte into r4
andhi r4, r4, 0xFF00

slli r2, r2, 0x8 # removes most significant byte

srli r4, r4, 0x18

call __read_byte # Gets bytes from msg into r10

xor r4, r4, r10 # xor bytes from msg and reg

slli r4, r4, 0x2 # each table position has 4 bytes, so multiply by 4

add r4, r4, r17 # r17 has first table address. r4 is table offset

ldw r6, 0(r4)

xor r2, r2, r6

addi r3, r3, 0x1 # increment iteration counter

br crc_loop

crc2lcd:
#movia r3, 0x3090 # Second argument is the address of the LCD in the Nios.
#stw r2, 0x0(r3)
#br begin_transmission

movia r20, 0x3080 # LED address on nios_project_13

stw r2, 0x10(r20)

# Reading button in busy waiting

# r13 gets btn last state
mov r13, r0

# r12 gets btn current state
read_btn:
  ldb r12, 0x00(r20) # BTN address on nios_project_13

beq r12, r13, read_btn

mov r13, r12

# Little logic debounce (in case the kit doesnt have)

movia r14, 0xFFFFF # r14 delay timing

delay:
subi r14, r14, 0x1
bne r14, r0, delay

# If new read is equal to previous, means signal is stable

ldb r14, 0x00(r20)

bne r14, r12, read_btn

beq r12, r0, read_btn

roli r2, r2, 0x4

stw r2, 0x10(r20) # LEDs address on nios_project_13

br read_btn

